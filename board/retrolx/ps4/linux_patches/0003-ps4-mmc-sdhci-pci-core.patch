--- a/drivers/mmc/host/sdhci-pci-core.c	2022-01-03 16:48:04.064915075 +0100
+++ b/drivers/mmc/host/sdhci-pci-core.c	2022-01-03 16:34:36.131127913 +0100
@@ -21,22 +21,17 @@
 #include <linux/mmc/mmc.h>
 #include <linux/scatterlist.h>
 #include <linux/io.h>
-#include <linux/iopoll.h>
 #include <linux/gpio.h>
 #include <linux/pm_runtime.h>
-#include <linux/pm_qos.h>
-#include <linux/debugfs.h>
 #include <linux/mmc/slot-gpio.h>
 #include <linux/mmc/sdhci-pci-data.h>
 #include <linux/acpi.h>
-#include <linux/dmi.h>
 
 #ifdef CONFIG_X86
 #include <asm/iosf_mbi.h>
 #endif
 
 #include "cqhci.h"
-
 #ifdef CONFIG_X86_PS4
 #include <asm/ps4.h>
 #endif
@@ -238,14 +233,6 @@
 	sdhci_dumpregs(mmc_priv(mmc));
 }
 
-static void sdhci_cqhci_reset(struct sdhci_host *host, u8 mask)
-{
-	if ((host->mmc->caps2 & MMC_CAP2_CQE) && (mask & SDHCI_RESET_ALL) &&
-	    host->mmc->cqe_private)
-		cqhci_deactivate(host->mmc);
-	sdhci_reset(host, mask);
-}
-
 /*****************************************************************************\
  *                                                                           *
  * Hardware specific quirk handling                                          *
@@ -263,8 +250,12 @@
 static int ricoh_mmc_probe_slot(struct sdhci_pci_slot *slot)
 {
 	slot->host->caps =
-		FIELD_PREP(SDHCI_TIMEOUT_CLK_MASK, 0x21) |
-		FIELD_PREP(SDHCI_CLOCK_BASE_MASK, 0x21) |
+		((0x21 << SDHCI_TIMEOUT_CLK_SHIFT)
+			& SDHCI_TIMEOUT_CLK_MASK) |
+
+		((0x21 << SDHCI_CLOCK_BASE_SHIFT)
+			& SDHCI_CLOCK_BASE_MASK) |
+
 		SDHCI_TIMEOUT_CLK_UNIT |
 		SDHCI_CAN_VDD_330 |
 		SDHCI_CAN_DO_HISPD |
@@ -322,7 +313,6 @@
 static const struct sdhci_pci_fixes sdhci_intel_qrk = {
 	.quirks		= SDHCI_QUIRK_NO_HISPD_BIT,
 };
-
 #ifdef CONFIG_X86_PS4
 static int aeolia_probe(struct sdhci_pci_chip *chip)
 {
@@ -338,7 +328,8 @@
 
 static int aeolia_probe_slot(struct sdhci_pci_slot *slot)
 {
-	int err = apcie_assign_irqs(slot->chip->pdev, 1);
+	int err = pci_alloc_irq_vectors(slot->chip->pdev, 1, INT_MAX,
+			PCI_IRQ_MSIX | PCI_IRQ_MSI);//apcie_assign_irqs(slot->chip->pdev, 1);
 	if (err <= 0) {
 		dev_err(&slot->chip->pdev->dev, "failed to get IRQ: %d\n", err);
 		return -ENODEV;
@@ -354,12 +345,14 @@
 
 static int aeolia_enable_dma(struct sdhci_pci_slot *slot)
 {
+
 	if (pci_set_dma_mask(slot->chip->pdev, DMA_BIT_MASK(31))) {
 		return -EINVAL;
 	}
 	if (pci_set_consistent_dma_mask(slot->chip->pdev, DMA_BIT_MASK(31))) {
 		return -EINVAL;
 	}
+
 	return 0;
 }
 
@@ -568,11 +561,8 @@
 	int	drv_strength;
 	bool	d3_retune;
 	bool	rpm_retune_ok;
-	bool	needs_pwr_off;
 	u32	glk_rx_ctrl1;
 	u32	glk_tun_val;
-	u32	active_ltr;
-	u32	idle_ltr;
 };
 
 static const guid_t intel_dsm_guid =
@@ -662,18 +652,19 @@
 	struct sdhci_pci_slot *slot = sdhci_priv(host);
 	struct intel_host *intel_host = sdhci_pci_priv(slot);
 
-	if (!(mmc_driver_type_mask(intel_host->drv_strength) & card_drv))
-		return 0;
-
 	return intel_host->drv_strength;
 }
 
-static int sdhci_get_cd_nogpio(struct mmc_host *mmc)
+static int bxt_get_cd(struct mmc_host *mmc)
 {
+	int gpio_cd = mmc_gpio_get_cd(mmc);
 	struct sdhci_host *host = mmc_priv(mmc);
 	unsigned long flags;
 	int ret = 0;
 
+	if (!gpio_cd)
+		return 0;
+
 	spin_lock_irqsave(&host->lock, flags);
 
 	if (host->flags & SDHCI_DEVICE_DEAD)
@@ -686,46 +677,15 @@
 	return ret;
 }
 
-static int bxt_get_cd(struct mmc_host *mmc)
-{
-	int gpio_cd = mmc_gpio_get_cd(mmc);
-
-	if (!gpio_cd)
-		return 0;
-
-	return sdhci_get_cd_nogpio(mmc);
-}
-
-static int mrfld_get_cd(struct mmc_host *mmc)
-{
-	return sdhci_get_cd_nogpio(mmc);
-}
-
 #define SDHCI_INTEL_PWR_TIMEOUT_CNT	20
 #define SDHCI_INTEL_PWR_TIMEOUT_UDELAY	100
 
 static void sdhci_intel_set_power(struct sdhci_host *host, unsigned char mode,
 				  unsigned short vdd)
 {
-	struct sdhci_pci_slot *slot = sdhci_priv(host);
-	struct intel_host *intel_host = sdhci_pci_priv(slot);
 	int cntr;
 	u8 reg;
 
-	/*
-	 * Bus power may control card power, but a full reset still may not
-	 * reset the power, whereas a direct write to SDHCI_POWER_CONTROL can.
-	 * That might be needed to initialize correctly, if the card was left
-	 * powered on previously.
-	 */
-	if (intel_host->needs_pwr_off) {
-		intel_host->needs_pwr_off = false;
-		if (mode != MMC_POWER_OFF) {
-			sdhci_writeb(host, 0, SDHCI_POWER_CONTROL);
-			usleep_range(10000, 12500);
-		}
-	}
-
 	sdhci_set_power(host, mode, vdd);
 
 	if (mode == MMC_POWER_OFF)
@@ -745,15 +705,6 @@
 	}
 }
 
-static void sdhci_intel_set_uhs_signaling(struct sdhci_host *host,
-					  unsigned int timing)
-{
-	/* Set UHS timing to SDR25 for High Speed mode */
-	if (timing == MMC_TIMING_MMC_HS || timing == MMC_TIMING_SD_HS)
-		timing = MMC_TIMING_UHS_SDR25;
-	sdhci_set_uhs_signaling(host, timing);
-}
-
 #define INTEL_HS400_ES_REG 0x78
 #define INTEL_HS400_ES_BIT BIT(0)
 
@@ -810,7 +761,7 @@
 	.enable_dma		= sdhci_pci_enable_dma,
 	.set_bus_width		= sdhci_set_bus_width,
 	.reset			= sdhci_reset,
-	.set_uhs_signaling	= sdhci_intel_set_uhs_signaling,
+	.set_uhs_signaling	= sdhci_set_uhs_signaling,
 	.hw_reset		= sdhci_pci_hw_reset,
 };
 
@@ -819,8 +770,8 @@
 	.set_power		= sdhci_intel_set_power,
 	.enable_dma		= sdhci_pci_enable_dma,
 	.set_bus_width		= sdhci_set_bus_width,
-	.reset			= sdhci_cqhci_reset,
-	.set_uhs_signaling	= sdhci_intel_set_uhs_signaling,
+	.reset			= sdhci_reset,
+	.set_uhs_signaling	= sdhci_set_uhs_signaling,
 	.hw_reset		= sdhci_pci_hw_reset,
 	.irq			= sdhci_cqhci_irq,
 };
@@ -853,108 +804,6 @@
 	return 0;
 }
 
-#define INTEL_ACTIVELTR		0x804
-#define INTEL_IDLELTR		0x808
-
-#define INTEL_LTR_REQ		BIT(15)
-#define INTEL_LTR_SCALE_MASK	GENMASK(11, 10)
-#define INTEL_LTR_SCALE_1US	(2 << 10)
-#define INTEL_LTR_SCALE_32US	(3 << 10)
-#define INTEL_LTR_VALUE_MASK	GENMASK(9, 0)
-
-static void intel_cache_ltr(struct sdhci_pci_slot *slot)
-{
-	struct intel_host *intel_host = sdhci_pci_priv(slot);
-	struct sdhci_host *host = slot->host;
-
-	intel_host->active_ltr = readl(host->ioaddr + INTEL_ACTIVELTR);
-	intel_host->idle_ltr = readl(host->ioaddr + INTEL_IDLELTR);
-}
-
-static void intel_ltr_set(struct device *dev, s32 val)
-{
-	struct sdhci_pci_chip *chip = dev_get_drvdata(dev);
-	struct sdhci_pci_slot *slot = chip->slots[0];
-	struct intel_host *intel_host = sdhci_pci_priv(slot);
-	struct sdhci_host *host = slot->host;
-	u32 ltr;
-
-	pm_runtime_get_sync(dev);
-
-	/*
-	 * Program latency tolerance (LTR) accordingly what has been asked
-	 * by the PM QoS layer or disable it in case we were passed
-	 * negative value or PM_QOS_LATENCY_ANY.
-	 */
-	ltr = readl(host->ioaddr + INTEL_ACTIVELTR);
-
-	if (val == PM_QOS_LATENCY_ANY || val < 0) {
-		ltr &= ~INTEL_LTR_REQ;
-	} else {
-		ltr |= INTEL_LTR_REQ;
-		ltr &= ~INTEL_LTR_SCALE_MASK;
-		ltr &= ~INTEL_LTR_VALUE_MASK;
-
-		if (val > INTEL_LTR_VALUE_MASK) {
-			val >>= 5;
-			if (val > INTEL_LTR_VALUE_MASK)
-				val = INTEL_LTR_VALUE_MASK;
-			ltr |= INTEL_LTR_SCALE_32US | val;
-		} else {
-			ltr |= INTEL_LTR_SCALE_1US | val;
-		}
-	}
-
-	if (ltr == intel_host->active_ltr)
-		goto out;
-
-	writel(ltr, host->ioaddr + INTEL_ACTIVELTR);
-	writel(ltr, host->ioaddr + INTEL_IDLELTR);
-
-	/* Cache the values into lpss structure */
-	intel_cache_ltr(slot);
-out:
-	pm_runtime_put_autosuspend(dev);
-}
-
-static bool intel_use_ltr(struct sdhci_pci_chip *chip)
-{
-	switch (chip->pdev->device) {
-	case PCI_DEVICE_ID_INTEL_BYT_EMMC:
-	case PCI_DEVICE_ID_INTEL_BYT_EMMC2:
-	case PCI_DEVICE_ID_INTEL_BYT_SDIO:
-	case PCI_DEVICE_ID_INTEL_BYT_SD:
-	case PCI_DEVICE_ID_INTEL_BSW_EMMC:
-	case PCI_DEVICE_ID_INTEL_BSW_SDIO:
-	case PCI_DEVICE_ID_INTEL_BSW_SD:
-		return false;
-	default:
-		return true;
-	}
-}
-
-static void intel_ltr_expose(struct sdhci_pci_chip *chip)
-{
-	struct device *dev = &chip->pdev->dev;
-
-	if (!intel_use_ltr(chip))
-		return;
-
-	dev->power.set_latency_tolerance = intel_ltr_set;
-	dev_pm_qos_expose_latency_tolerance(dev);
-}
-
-static void intel_ltr_hide(struct sdhci_pci_chip *chip)
-{
-	struct device *dev = &chip->pdev->dev;
-
-	if (!intel_use_ltr(chip))
-		return;
-
-	dev_pm_qos_hide_latency_tolerance(dev);
-	dev->power.set_latency_tolerance = NULL;
-}
-
 static void byt_probe_slot(struct sdhci_pci_slot *slot)
 {
 	struct mmc_host_ops *ops = &slot->host->mmc_host_ops;
@@ -969,43 +818,6 @@
 	ops->start_signal_voltage_switch = intel_start_signal_voltage_switch;
 
 	device_property_read_u32(dev, "max-frequency", &mmc->f_max);
-
-	if (!mmc->slotno) {
-		slot->chip->slots[mmc->slotno] = slot;
-		intel_ltr_expose(slot->chip);
-	}
-}
-
-static void byt_add_debugfs(struct sdhci_pci_slot *slot)
-{
-	struct intel_host *intel_host = sdhci_pci_priv(slot);
-	struct mmc_host *mmc = slot->host->mmc;
-	struct dentry *dir = mmc->debugfs_root;
-
-	if (!intel_use_ltr(slot->chip))
-		return;
-
-	debugfs_create_x32("active_ltr", 0444, dir, &intel_host->active_ltr);
-	debugfs_create_x32("idle_ltr", 0444, dir, &intel_host->idle_ltr);
-
-	intel_cache_ltr(slot);
-}
-
-static int byt_add_host(struct sdhci_pci_slot *slot)
-{
-	int ret = sdhci_add_host(slot->host);
-
-	if (!ret)
-		byt_add_debugfs(slot);
-	return ret;
-}
-
-static void byt_remove_slot(struct sdhci_pci_slot *slot, int dead)
-{
-	struct mmc_host *mmc = slot->host->mmc;
-
-	if (!mmc->slotno)
-		intel_ltr_hide(slot->chip);
 }
 
 static int byt_emmc_probe_slot(struct sdhci_pci_slot *slot)
@@ -1023,22 +835,14 @@
 	return 0;
 }
 
-static bool glk_broken_cqhci(struct sdhci_pci_slot *slot)
-{
-	return slot->chip->pdev->device == PCI_DEVICE_ID_INTEL_GLK_EMMC &&
-	       (dmi_match(DMI_BIOS_VENDOR, "LENOVO") ||
-		dmi_match(DMI_SYS_VENDOR, "IRBIS"));
-}
-
 static int glk_emmc_probe_slot(struct sdhci_pci_slot *slot)
 {
 	int ret = byt_emmc_probe_slot(slot);
 
-	if (!glk_broken_cqhci(slot))
-		slot->host->mmc->caps2 |= MMC_CAP2_CQE;
+	slot->host->mmc->caps2 |= MMC_CAP2_CQE;
 
 	if (slot->chip->pdev->device != PCI_DEVICE_ID_INTEL_GLK_EMMC) {
-		slot->host->mmc->caps2 |= MMC_CAP2_HS400_ES;
+		slot->host->mmc->caps2 |= MMC_CAP2_HS400_ES,
 		slot->host->mmc_host_ops.hs400_enhanced_strobe =
 						intel_hs400_enhanced_strobe;
 		slot->host->mmc->caps2 |= MMC_CAP2_CQE_DCMD;
@@ -1087,8 +891,6 @@
 	if (ret)
 		goto cleanup;
 
-	byt_add_debugfs(slot);
-
 	return 0;
 
 cleanup:
@@ -1215,14 +1017,6 @@
 	return 0;
 }
 
-static void byt_needs_pwr_off(struct sdhci_pci_slot *slot)
-{
-	struct intel_host *intel_host = sdhci_pci_priv(slot);
-	u8 reg = sdhci_readb(slot->host, SDHCI_POWER_CONTROL);
-
-	intel_host->needs_pwr_off = reg  & SDHCI_POWER_ON;
-}
-
 static int byt_sd_probe_slot(struct sdhci_pci_slot *slot)
 {
 	byt_probe_slot(slot);
@@ -1240,8 +1034,6 @@
 	    slot->chip->pdev->subsystem_device == PCI_SUBDEVICE_ID_NI_78E3)
 		slot->host->mmc->caps2 |= MMC_CAP2_AVOID_3_3V;
 
-	byt_needs_pwr_off(slot);
-
 	return 0;
 }
 
@@ -1276,8 +1068,6 @@
 #endif
 	.allow_runtime_pm = true,
 	.probe_slot	= byt_emmc_probe_slot,
-	.add_host	= byt_add_host,
-	.remove_slot	= byt_remove_slot,
 	.quirks		= SDHCI_QUIRK_NO_ENDATTR_IN_NOPDESC |
 			  SDHCI_QUIRK_NO_LED,
 	.quirks2	= SDHCI_QUIRK2_PRESET_VALUE_BROKEN |
@@ -1291,7 +1081,6 @@
 	.allow_runtime_pm	= true,
 	.probe_slot		= glk_emmc_probe_slot,
 	.add_host		= glk_emmc_add_host,
-	.remove_slot		= byt_remove_slot,
 #ifdef CONFIG_PM_SLEEP
 	.suspend		= sdhci_cqhci_suspend,
 	.resume			= sdhci_cqhci_resume,
@@ -1322,8 +1111,6 @@
 			  SDHCI_QUIRK2_PRESET_VALUE_BROKEN,
 	.allow_runtime_pm = true,
 	.probe_slot	= ni_byt_sdio_probe_slot,
-	.add_host	= byt_add_host,
-	.remove_slot	= byt_remove_slot,
 	.ops		= &sdhci_intel_byt_ops,
 	.priv_size	= sizeof(struct intel_host),
 };
@@ -1341,8 +1128,6 @@
 			SDHCI_QUIRK2_PRESET_VALUE_BROKEN,
 	.allow_runtime_pm = true,
 	.probe_slot	= byt_sdio_probe_slot,
-	.add_host	= byt_add_host,
-	.remove_slot	= byt_remove_slot,
 	.ops		= &sdhci_intel_byt_ops,
 	.priv_size	= sizeof(struct intel_host),
 };
@@ -1362,8 +1147,6 @@
 	.allow_runtime_pm = true,
 	.own_cd_for_runtime_pm = true,
 	.probe_slot	= byt_sd_probe_slot,
-	.add_host	= byt_add_host,
-	.remove_slot	= byt_remove_slot,
 	.ops		= &sdhci_intel_byt_ops,
 	.priv_size	= sizeof(struct intel_host),
 };
@@ -1404,14 +1187,6 @@
 					 MMC_CAP_1_8V_DDR;
 		break;
 	case INTEL_MRFLD_SD:
-		slot->cd_idx = 0;
-		slot->cd_override_level = true;
-		/*
-		 * There are two PCB designs of SD card slot with the opposite
-		 * card detection sense. Quirk this out by ignoring GPIO state
-		 * completely in the custom ->get_cd() callback.
-		 */
-		slot->host->mmc_host_ops.get_cd = mrfld_get_cd;
 		slot->host->quirks2 |= SDHCI_QUIRK2_NO_1_8_V;
 		break;
 	case INTEL_MRFLD_SDIO:
@@ -1627,6 +1402,7 @@
 }
 #endif
 
+
 static const struct sdhci_pci_fixes sdhci_jmicron = {
 	.probe		= jmicron_probe,
 
@@ -1868,59 +1644,11 @@
 	return 0;
 }
 
-static u32 sdhci_read_present_state(struct sdhci_host *host)
-{
-	return sdhci_readl(host, SDHCI_PRESENT_STATE);
-}
-
-static void amd_sdhci_reset(struct sdhci_host *host, u8 mask)
-{
-	struct sdhci_pci_slot *slot = sdhci_priv(host);
-	struct pci_dev *pdev = slot->chip->pdev;
-	u32 present_state;
-
-	/*
-	 * SDHC 0x7906 requires a hard reset to clear all internal state.
-	 * Otherwise it can get into a bad state where the DATA lines are always
-	 * read as zeros.
-	 */
-	if (pdev->device == 0x7906 && (mask & SDHCI_RESET_ALL)) {
-		pci_clear_master(pdev);
-
-		pci_save_state(pdev);
-
-		pci_set_power_state(pdev, PCI_D3cold);
-		pr_debug("%s: power_state=%u\n", mmc_hostname(host->mmc),
-			pdev->current_state);
-		pci_set_power_state(pdev, PCI_D0);
-
-		pci_restore_state(pdev);
-
-		/*
-		 * SDHCI_RESET_ALL says the card detect logic should not be
-		 * reset, but since we need to reset the entire controller
-		 * we should wait until the card detect logic has stabilized.
-		 *
-		 * This normally takes about 40ms.
-		 */
-		readx_poll_timeout(
-			sdhci_read_present_state,
-			host,
-			present_state,
-			present_state & SDHCI_CD_STABLE,
-			10000,
-			100000
-		);
-	}
-
-	return sdhci_reset(host, mask);
-}
-
 static const struct sdhci_ops amd_sdhci_pci_ops = {
 	.set_clock			= sdhci_set_clock,
 	.enable_dma			= sdhci_pci_enable_dma,
 	.set_bus_width			= sdhci_set_bus_width,
-	.reset				= amd_sdhci_reset,
+	.reset				= sdhci_reset,
 	.set_uhs_signaling		= sdhci_set_uhs_signaling,
 };
 
@@ -1998,11 +1726,6 @@
 	SDHCI_PCI_DEVICE(INTEL, EHL_SD,    intel_byt_sd),
 	SDHCI_PCI_DEVICE(INTEL, CML_EMMC,  intel_glk_emmc),
 	SDHCI_PCI_DEVICE(INTEL, CML_SD,    intel_byt_sd),
-	SDHCI_PCI_DEVICE(INTEL, CMLH_SD,   intel_byt_sd),
-	SDHCI_PCI_DEVICE(INTEL, JSL_EMMC,  intel_glk_emmc),
-	SDHCI_PCI_DEVICE(INTEL, JSL_SD,    intel_byt_sd),
-	SDHCI_PCI_DEVICE(INTEL, LKF_EMMC,  intel_glk_emmc),
-	SDHCI_PCI_DEVICE(INTEL, LKF_SD,    intel_byt_sd),
 	SDHCI_PCI_DEVICE(O2, 8120,     o2),
 	SDHCI_PCI_DEVICE(O2, 8220,     o2),
 	SDHCI_PCI_DEVICE(O2, 8221,     o2),
@@ -2015,18 +1738,15 @@
 	SDHCI_PCI_DEVICE(O2, SEABIRD1, o2),
 	SDHCI_PCI_DEVICE(ARASAN, PHY_EMMC, arasan),
 	SDHCI_PCI_DEVICE(SYNOPSYS, DWC_MSHC, snps),
-	#ifdef CONFIG_X86_PS4
+#ifdef CONFIG_X86_PS4
 	SDHCI_PCI_DEVICE(SONY, AEOLIA_SDHCI, aeolia),
 	SDHCI_PCI_DEVICE(SONY, BELIZE_SDHCI, aeolia),
-	// TODO (ps4patches): What is this doing in comments?
-	//SDHCI_PCI_DEVICE(SONY, BAIKAL_SDHCI, aeolia),
-	#endif
-	SDHCI_PCI_DEVICE(GLI, 9750, gl9750),
-	SDHCI_PCI_DEVICE(GLI, 9755, gl9755),
-	SDHCI_PCI_DEVICE(GLI, 9763E, gl9763e),
+	SDHCI_PCI_DEVICE(SONY, BAIKAL_SDHCI, aeolia),
+#endif
 	SDHCI_PCI_DEVICE_CLASS(AMD, SYSTEM_SDHCI, PCI_CLASS_MASK, amd),
 	/* Generic SD host controller */
 	{PCI_DEVICE_CLASS(SYSTEM_SDHCI, PCI_CLASS_MASK)},
+
 	{ /* end: all zeroes */ },
 };
 
@@ -2055,9 +1775,9 @@
 
 	pci_set_master(pdev);
 
-	if (slot->chip->fixes && slot->chip->fixes->enable_dma) {
-		return slot->chip->fixes->enable_dma(slot);
-	}
+ 	if (slot->chip->fixes && slot->chip->fixes->enable_dma) {
+ 		return slot->chip->fixes->enable_dma(slot);
+ 	}
 
 	return 0;
 }
@@ -2103,7 +1823,8 @@
 #ifdef CONFIG_PM_SLEEP
 static int sdhci_pci_suspend(struct device *dev)
 {
-	struct sdhci_pci_chip *chip = dev_get_drvdata(dev);
+	struct pci_dev *pdev = to_pci_dev(dev);
+	struct sdhci_pci_chip *chip = pci_get_drvdata(pdev);
 
 	if (!chip)
 		return 0;
@@ -2116,7 +1837,8 @@
 
 static int sdhci_pci_resume(struct device *dev)
 {
-	struct sdhci_pci_chip *chip = dev_get_drvdata(dev);
+	struct pci_dev *pdev = to_pci_dev(dev);
+	struct sdhci_pci_chip *chip = pci_get_drvdata(pdev);
 
 	if (!chip)
 		return 0;
@@ -2131,7 +1853,8 @@
 #ifdef CONFIG_PM
 static int sdhci_pci_runtime_suspend(struct device *dev)
 {
-	struct sdhci_pci_chip *chip = dev_get_drvdata(dev);
+	struct pci_dev *pdev = to_pci_dev(dev);
+	struct sdhci_pci_chip *chip = pci_get_drvdata(pdev);
 
 	if (!chip)
 		return 0;
@@ -2144,7 +1867,8 @@
 
 static int sdhci_pci_runtime_resume(struct device *dev)
 {
-	struct sdhci_pci_chip *chip = dev_get_drvdata(dev);
+	struct pci_dev *pdev = to_pci_dev(dev);
+	struct sdhci_pci_chip *chip = pci_get_drvdata(pdev);
 
 	if (!chip)
 		return 0;
@@ -2169,12 +1893,13 @@
 \*****************************************************************************/
 
 static struct sdhci_pci_slot *sdhci_pci_probe_slot(
-	struct pci_dev *pdev, struct sdhci_pci_chip *chip, int first_bar,
+	struct pci_dev *pdev, struct sdhci_pci_chip *chip,
 	int slotno)
 {
 	struct sdhci_pci_slot *slot;
 	struct sdhci_host *host;
-	int ret, bar = first_bar + slotno;
+	int ret, bar = chip->first_bar + slotno;
+	//int ret, bar = first_bar + slotno;
 	size_t priv_size = chip->fixes ? chip->fixes->priv_size : 0;
 
 	if (!(pci_resource_flags(pdev, bar) & IORESOURCE_MEM)) {
@@ -2273,12 +1998,12 @@
 
 	if (slot->cd_idx >= 0) {
 		ret = mmc_gpiod_request_cd(host->mmc, "cd", slot->cd_idx,
-					   slot->cd_override_level, 0);
+					   slot->cd_override_level, 0, NULL);
 		if (ret && ret != -EPROBE_DEFER)
 			ret = mmc_gpiod_request_cd(host->mmc, NULL,
 						   slot->cd_idx,
 						   slot->cd_override_level,
-						   0);
+						   0, NULL);
 		if (ret == -EPROBE_DEFER)
 			goto remove;
 
@@ -2427,11 +2152,8 @@
 	slots = chip->num_slots;	/* Quirk may have changed this */
 
 	for (i = 0; i < slots; i++) {
-		#ifdef CONFIG_X86_PS4
-		slot = sdhci_pci_probe_slot(pdev, chip, chip->first_bar, i);
-		#else
-		slot = sdhci_pci_probe_slot(pdev, chip, first_bar, i);
-		#endif
+		slot = sdhci_pci_probe_slot(pdev, chip, i);
+		//slot = sdhci_pci_probe_slot(pdev, chip, first_bar, i);
 		if (IS_ERR(slot)) {
 			for (i--; i >= 0; i--)
 				sdhci_pci_remove_slot(chip->slots[i]);
